on:
  workflow_call:
    inputs:
      server-ip:
        description: "IP publica del servidor"
        required: true
        type: string
      server-user:
        description: "SSH host (user@ip)"
        required: false
        type: string
        default: "ubuntu"
      deploy-path:
        description: "Ruta remota donde se va a subir el backend"
        required: true
        type: string
      deployment-files:
        description: 'Files to include in deployment (space separated)'
        required: false
        default: 'src/ migrations/ seeders/ index.ts app.ts drizzle.config.prod.ts package.json tsconfig.json Dockerfile docker-compose.yml'
        type: string
    secrets:
      ssh-private-key:
        description: "Clave privada SSH"
        required: true
      env-file-content:
        description: ".env completo"
        required: true

env:
  SSH_AUTH_SOCK: /tmp/ssh_agent.sock

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH private key
        env:
          SSH_PRIVATE_KEY: ${{ secrets.ssh-private-key }}
        run: |
          ssh-agent -a $SSH_AUTH_SOCK > /dev/null
          echo "$SSH_PRIVATE_KEY" | ssh-add - >/dev/null

      - name: Create deployment package
        run: |
          mkdir -p deployment
          # Copiar archivos especificados
          for file in ${{ inputs.deployment-files }}; do
            if [ -e "$file" ]; then
              cp -r "$file" deployment/
            else
              echo "Warning: $file not found"
            fi
          done
          
          tar -czf deployment.tar.gz deployment/
          echo "Deployment package created"

      - name: Prepare server directory
        env:
          ENV_CONTENT: ${{ secrets.env-file-content }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ inputs.server-user }}@${{ inputs.server-ip }} "\
            mkdir -p ${{ inputs.deploy-path }} && \
            rm -rf ${{ inputs.deploy-path }}/* && \
            echo '$ENV_CONTENT' > ${{ inputs.deploy-path }}/.env"

      - name: Upload deployment package
        run: |
          scp -o StrictHostKeyChecking=no deployment.tar.gz ${{ inputs.server-user }}@${{ inputs.server-ip }}:${{ inputs.deploy-path }}

      - name: Deploy with Docker
        run: |
          ssh -o StrictHostKeyChecking=no ${{ inputs.server-user }}@${{ inputs.server-ip }} "\
            cd ${{ inputs.deploy-path }} && \
            tar -xzf deployment.tar.gz --strip-components=1
            rm -f deployment.tar.gz

            docker compose down && \
            docker compose build && \
            docker compose run back npm run db:prod:migrate && \
            docker compose up --remove-orphans -d"

      - name: Health Check
        env:
          HEALTHCHECK_URL: ${{ inputs.server-ip }}/api/v1/eso
          EXPECTED_BODY: brad
        run: |
          for i in {1..10}; do
            status_code=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTHCHECK_URL")
            body=$(curl -s "$HEALTHCHECK_URL")

            if [ "$status_code" = "200" ]; then
              if [ -z "$EXPECTED_BODY" ] || [ "$body" = "$EXPECTED_BODY" ]; then
                echo "✅ Server is up and returning expected response!"
                exit 0
              fi
            fi
            
            echo "⏳ Attempt $i: Server not ready yet (Status: $status_code), waiting 5 seconds..."
            sleep 5
          done
          
          echo "❌ Server did not return expected response in time"
          exit 1
